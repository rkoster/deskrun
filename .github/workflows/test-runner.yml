name: Test Self-Hosted Runner

on:
  push:
    branches: [copilot/implement-github-actions-runner]
  workflow_dispatch:

# Note: To enable Nix store caching for faster builds, add `--cache /nix/store` 
# when installing the runner with:
# deskrun add test-runner --repository <url> --mode cached-privileged-kubernetes --cache /nix/store --auth-type pat --auth-value <token>

jobs:
  test:
    runs-on: test-runner
    container:
      image: ghcr.io/nixos/nix:latest
      options: --privileged
    steps:
      - name: Start Docker daemon
        run: |
          # Create necessary directories
          mkdir -p /var/lib/docker
          mkdir -p /var/run
          mkdir -p /tmp/dind
          mkdir -p /etc/docker
          mkdir -p /var/log

          # Install Docker via nix
          nix-env -i docker

          # Write Docker daemon configuration with vfs driver
          # (vfs driver works better in Kubernetes environments)
          cat > /etc/docker/daemon.json <<'EOF'
          {
            "log-driver": "json-file",
            "log-opts": {
              "max-size": "100m"
            },
            "storage-driver": "vfs"
          }
          EOF

          # Enable cgroup v2 controller delegation for nested containers
          # This allows kind containers to run systemd properly
          echo '+cpuset +cpu +io +memory +pids' > /sys/fs/cgroup/cgroup.subtree_control 2>/dev/null || {
            # If direct write fails, move processes to init.scope first
            mkdir -p /sys/fs/cgroup/init.scope
            # Copy PIDs to temp file to avoid reading and writing cgroup.procs simultaneously
            cp /sys/fs/cgroup/cgroup.procs /tmp/cgroup-pids.txt
            while IFS= read -r pid; do
              echo "$pid" > /sys/fs/cgroup/init.scope/cgroup.procs 2>/dev/null || true
            done < /tmp/cgroup-pids.txt
            rm -f /tmp/cgroup-pids.txt
            # Retry delegation after moving processes
            echo '+cpuset +cpu +io +memory +pids' > /sys/fs/cgroup/cgroup.subtree_control
          }

          # Start dockerd in the background with custom socket path
          dockerd \
              --host=unix:///tmp/dind/docker.sock \
              --config-file=/etc/docker/daemon.json \
              --data-root=/var/lib/docker \
              --log-level=error \
              >/var/log/dockerd.log 2>&1 &

          # Wait for docker daemon to be ready
          echo "Waiting for Docker daemon to start..."
          timeout=30
          while ! DOCKER_HOST=unix:///tmp/dind/docker.sock docker info >/dev/null 2>&1; do
              sleep 1
              timeout=$((timeout - 1))
              if [ "$timeout" -le 0 ]; then
                  echo "Error: Docker daemon failed to start within 30 seconds"
                  cat /var/log/dockerd.log || true
                  exit 1
              fi
          done

           echo "Docker daemon started successfully"

       - name: Test Docker availability
         run: |
           export DOCKER_HOST=unix:///tmp/dind/docker.sock
           echo "Testing Docker daemon availability..."
           docker info
           docker ps
           echo "Docker is working!"

      - name: Test basic Docker operations
        run: |
          export DOCKER_HOST=unix:///tmp/dind/docker.sock
          echo "Testing basic Docker operations..."
          docker pull alpine:latest --quiet || docker pull alpine:latest
          docker run --rm alpine:latest echo "Docker run successful!"
          echo "All Docker tests passed!"

